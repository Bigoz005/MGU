<html>
<head>
<meta charset="UTF-8" />
<title>MGU</title>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"> </script>
<script src="fabric.js"></script>

<script>

let model;
let canvas;
let symbols = [{}];
let coords = [] ;
let mousePressed = false; 
let result; 

 //prepare the drawing canvas 
$(function () {
    canvas = window._canvas = new fabric.Canvas('canvas');
    canvas.backgroundColor = '#ffffff';
    canvas.isDrawingMode= 0;
    canvas.freeDrawingBrush.color = "black";
    canvas.freeDrawingBrush.width = 10;
    canvas.renderAll();
    
    canvas.on('mouse:up', function(e){mousePressed = false});
    canvas.on('mouse:down', function(e){mousePressed = true});
    canvas.on('mouse:move', function(e){trackCursor(e)});

    loadModel();
})
	  
//record the current drawing coordinates 	  
function trackCursor(event)
{
  var pointer = canvas.getPointer(event.e);
  var posX = pointer.x;
  var posY = pointer.y;
  
  if(posX >=0 && posY >= 0 && mousePressed)  
  {	  
    coords.push(pointer) 
  } 
}
	  
//get the best bounding box by trimming around the trimming   
function getMinBox(){
   let minX = 0;
   let minY = 0;
   let maxX = 1000;
   let maxY = 400; 
	
   var coorX = coords.map(function(p) {return p.x});
   var coorY = coords.map(function(p) {return p.y});

   var min_coords = {
    x : Math.min.apply(null, coorX),
    y : Math.min.apply(null, coorY)
   }
   var max_coords = {
    x : Math.max.apply(null, coorX),
    y : Math.max.apply(null, coorY)
   }
   return {
    min : min_coords,
    max : max_coords
   }
}
	  
//get the current frame of the canvas 	  	  
function getFrame()
{
  console.log("getFrame");
  //make sure we have at least two recorded coordinates 
  if (coords.length >= 2){
	  //get the minimum bounding box
	  const mbb = getMinBox()
	  const dpi = window.devicePixelRatio
	  imgData = canvas.contextContainer.getImageData(mbb.min.x * dpi, mbb.min.y * dpi, (mbb.max.x - mbb.min.x) * dpi, (mbb.max.y - mbb.min.y) * dpi);
    return imgData
  }else{
    console.log("coords.length: '" + coords.length + "' is not enough");
  } 
}
 
//preprocess the data 
function preprocess(imgData)
{
  console.log("preprocess");
  console.log(imgData)
return tf.tidy(()=>{	  
    const tensor = tf.browser.fromPixels(imgData).toFloat()
    const offset = tf.scalar(255.0);
    // Normalize the image 
    const normalized = tf.scalar(1.0).sub(tensor.div(offset));
    const resized = tf.image.resizeBilinear(normalized, [28, 28])
    const sliced   = resized.slice([0, 0, 1], [28, 28, 1])
    const batched = sliced.expandDims(0)
    return batched
    console.log("batched: " + batched)
    return batched
})
}
	  
async function loadModel()
{
  //model.json -> model from collab  
  console.log('loading model')
  model = await tf.loadLayersModel('model.json')
  model.predict(tf.zeros([1,28,28,1]))
  allowDrawing();
  await loadDict()
  console.log('model loaded')
}
	   
function allowDrawing(){
    canvas.isDrawingMode= 1;
    $('button').prop('disabled', false); 
    var slider = document.getElementById('myRange');
    var textRange = document.getElementById('textRange');
    slider.oninput = function()
      {
        canvas.freeDrawingBrush.width = this.value;
        textRange.innerHTML = "Width: " + this.value; 
      };
}	  

function erase()
{
    canvas.clear();
    canvas.backgroundColor = '#ffffff';
    coords = [] ;
}

function submit(){
  var img = getFrame();
  if(img != null){
    var normalizedImg = preprocess(img);
    if(normalizedImg != null){
      predict(normalizedImg);
    }
  }
}

function predict(normalizedImg){
  console.log("predict");
  //const example = tf.browser.fromPixels(new ImageData(width=28,height=28,dataArray=normalizedImg));  // for example
  const prediction = model.predict(normalizedImg).dataSync();
  console.log("prediction: " + prediction);
  const indices = findIndicesOfMax(prediction, 5)
  console.log("indices: " + indices)
	const probs  = findTopValues(prediction, 5)
  console.log("probs: " + probs)
	const symbols = getSymbols(indices)
  console.log("symbols: " + symbols)
  const percentage =  probs[0].toString().substring(2,4) + ',' + probs[0].toString().substring(5,7)
  result = "It's a " + symbols[0] + '(' + percentage + '%)';
  this.document.getElementById("result").innerHTML = result
}	  

function findIndicesOfMax(inp, count) {
    var outp = [];
    for (var i = 0; i < inp.length; i++) {
        outp.push(i); // add index to output array
        if (outp.length > count) {
            outp.sort(function(a, b) { return inp[b] - inp[a]; }); // descending sort the output array
            outp.pop(); // remove the last index (index of smallest element in output array)
        }
    }
    return outp;
}

//find the top 5 predictions 
function findTopValues(inp, count){
    var outp = [];
    let indices = findIndicesOfMax(inp, count)
    // show 5 greatest scores
    for (var i = 0; i < indices.length; i++)
        outp[i] = inp[indices[i]]
    return outp
}

function getSymbols(indices)
{
    var outp = []
    for (var i= 0 ; i < indices.length ; i++)
        outp[i] = symbols[indices[i]]
    return outp
}

//load the class names 	  
async function loadDict()
{
  console.log("load class names")
  await $.ajax({
  url: '/class_names.txt',
  dataType: 'text'}).done(success);
}
	  
//load the class names 
function success(data)
{
    lst = data.split(/\n/)
    symbols = []
    for(var i = 0 ; i < lst.length -1  ; i++)
    {
        let symbol = lst[i]
        symbols[i] = symbol
    }
}

</script>

<style>
.slider {
    -webkit-appearance: none;
    width: 230px;
    height: 1px;
    border-radius: 3px;
    background: #d3d3d3;
    outline: none;
    opacity: 0.8;
    cursor: pointer;
}
</style>

</head>

<body>
<nav style="text-align: center;">
  <h1>MGU</h1>
</nav>
  <div class="col" style ="margin: auto; padding: 10px; text-align: center;">
    <canvas id="canvas" width="1000" height="400" style="border:1px solid gray; margin-top:10px; margin-left: 18%; margin-right: 18%;"></canvas>
    <div class="btn-group" style = 'margin-top:40px; text-align: center;'>
      <label id="textRange">Width: 10</label>
      <input type="range" min="5" max="15" value="10" class="slider" id="myRange" style ='margin-top:20px; margin-left:10px'>
      <button type="button" class="btn btn-outline-primary" onclick ='erase()' style ='margin-left:10px;' disabled>Clear</button>
      <button type="button" class="btn btn-outline-primary" onclick ='submit()' style ='margin-left:10px;' disabled>Submit</button>
    </div>
  <p id="result"> </p>
</div>
</body>
</html>
